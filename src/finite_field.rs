// Copyright (c) 2020 Apple Inc.
// SPDX-License-Identifier: MPL-2.0

//! Finite field arithmetic over a prime field using a 32bit prime.

use crate::fp::{FP126, FP32, FP64, FP80};
use std::{
    cmp::min,
    convert::TryFrom,
    fmt::{Debug, Display, Formatter},
    ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Neg, Sub, SubAssign},
};

use rand::Rng;

/// Possible errors from finite field operations.
#[derive(Debug, thiserror::Error)]
pub enum FiniteFieldError {
    /// Input sizes do not match
    #[error("input sizes do not match")]
    InputSizeMismatch,
}

/// Objects with this trait represent an element of `GF(p)` for some prime `p`.
pub trait FieldElement:
    Sized
    + Debug
    + Copy
    + PartialEq
    + Eq
    + Add<Output = Self>
    + AddAssign
    + Sub<Output = Self>
    + SubAssign
    + Mul<Output = Self>
    + MulAssign
    + Div<Output = Self>
    + DivAssign
    + Neg<Output = Self>
    + Display
    + From<<Self as FieldElement>::Integer>
{
    /// The error returned if converting `usize` to an `Int` fails.
    type IntegerTryFromError: std::fmt::Debug;

    /// The integer representation of the field element.
    type Integer: Copy
        + Debug
        + Sub<Output = <Self as FieldElement>::Integer>
        + TryFrom<usize, Error = Self::IntegerTryFromError>;

    /// Modular exponentation, i.e., `self^exp (mod p)`.
    fn pow(&self, exp: Self) -> Self; // TODO(cjpatton) exp should have type Self::Integer

    /// Modular inversion, i.e., `self^-1 (mod p)`. If `self` is 0, then the output is undefined.
    fn inv(&self) -> Self;

    /// Returns the prime modulus `p`.
    fn modulus() -> Self::Integer;

    /// Returns the size of the multiplicative subgroup generated by `generator()`.
    fn generator_order() -> Self::Integer;

    /// Returns the generator of the multiplicative subgroup of size `generator_order()`.
    fn generator() -> Self;

    /// Returns the `2^l`-th principal root of unity for any `l <= 20`. Note that the `2^0`-th
    /// prinicpal root of unity is 1 by definition.
    fn root(l: usize) -> Option<Self>;

    /// Returns a random field element distributed uniformly over all field elements.
    fn rand<R: Rng + ?Sized>(rng: &mut R) -> Self;

    /// Returns the additive identity.
    fn zero() -> Self;
}

macro_rules! make_field {
    (
        $(#[$meta:meta])*
        $elem:ident, $int:ident, $fp:ident
    ) => {
        $(#[$meta])*
        #[derive(Clone, Copy, Debug, PartialOrd, Ord, Hash, Default)]
        pub struct $elem(u128);

        impl PartialEq for $elem {
            fn eq(&self, rhs: &Self) -> bool {
                $fp.from_elem(self.0) == $fp.from_elem(rhs.0)
            }
        }

        impl Eq for $elem {}

        impl Add for $elem {
            type Output = $elem;
            fn add(self, rhs: Self) -> Self {
                Self($fp.add(self.0, rhs.0))
            }
        }

        impl Add for &$elem {
            type Output = $elem;
            fn add(self, rhs: Self) -> $elem {
                *self + *rhs
            }
        }

        impl AddAssign for $elem {
            fn add_assign(&mut self, rhs: Self) {
                *self = *self + rhs;
            }
        }

        impl Sub for $elem {
            type Output = $elem;
            fn sub(self, rhs: Self) -> Self {
                Self($fp.sub(self.0, rhs.0))
            }
        }

        impl Sub for &$elem {
            type Output = $elem;
            fn sub(self, rhs: Self) -> $elem {
                *self - *rhs
            }
        }

        impl SubAssign for $elem {
            fn sub_assign(&mut self, rhs: Self) {
                *self = *self - rhs;
            }
        }

        impl Mul for $elem {
            type Output = $elem;
            fn mul(self, rhs: Self) -> Self {
                Self($fp.mul(self.0, rhs.0))
            }
        }

        impl Mul for &$elem {
            type Output = $elem;
            fn mul(self, rhs: Self) -> $elem {
                *self * *rhs
            }
        }

        impl MulAssign for $elem {
            fn mul_assign(&mut self, rhs: Self) {
                *self = *self * rhs;
            }
        }

        impl Div for $elem {
            type Output = $elem;
            fn div(self, rhs: Self) -> Self {
                self * rhs.inv()
            }
        }

        impl Div for &$elem {
            type Output = $elem;
            fn div(self, rhs: Self) -> $elem {
                *self / *rhs
            }
        }

        impl DivAssign for $elem {
            fn div_assign(&mut self, rhs: Self) {
                *self = *self / rhs;
            }
        }

        impl Neg for $elem {
            type Output = $elem;
            fn neg(self) -> Self {
                Self($fp.neg(self.0))
            }
        }

        impl Neg for &$elem {
            type Output = $elem;
            fn neg(self) -> $elem {
                -(*self)
            }
        }

        impl From<$int> for $elem {
            fn from(x: $int) -> Self {
                Self($fp.elem(u128::try_from(x).unwrap()))
            }
        }

        impl From<$elem> for $int {
            fn from(x: $elem) -> Self {
                $int::try_from($fp.from_elem(x.0)).unwrap()
            }
        }

        impl PartialEq<$int> for $elem {
            fn eq(&self, rhs: &$int) -> bool {
                $fp.from_elem(self.0) == u128::try_from(*rhs).unwrap()
            }
        }

        impl Display for $elem {
            fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {
                write!(f, "{}", $fp.from_elem(self.0))
            }
        }

        impl FieldElement for $elem {
            type Integer = $int;
            type IntegerTryFromError = <Self::Integer as TryFrom<usize>>::Error;

            fn pow(&self, exp: Self) -> Self {
                Self($fp.pow(self.0, $fp.from_elem(exp.0)))
            }

            fn inv(&self) -> Self {
                Self($fp.inv(self.0))
            }

            fn modulus() -> Self::Integer {
                $fp.p as $int
            }

            fn generator() -> Self {
                Self($fp.g)
            }

            fn generator_order() -> Self::Integer {
                1 << (Self::Integer::try_from($fp.num_roots).unwrap())
            }

            fn root(l: usize) -> Option<Self> {
                if l < min($fp.roots.len(), $fp.num_roots+1) {
                    Some(Self($fp.roots[l]))
                } else {
                    None
                }
            }

            fn rand<R: Rng + ?Sized>(rng: &mut R) -> Self {
                Self($fp.rand_elem(rng))
            }

            fn zero() -> Self {
                Self(0)
            }
        }
    };
}

// TODO(cjpatton) Rename this to Field32.
make_field!(
    /// `GF(4293918721)`, a 32-bit field. The generator has order `2^20`.
    Field,
    u32,
    FP32
);

make_field!(
    /// `GF(15564440312192434177)`, a 64-bit field. The generator has order `2^59`.
    Field64,
    u64,
    FP64
);

make_field!(
    /// `GF(779190469673491460259841)`, an 80-bit field. The generator has order `2^72`.
    Field80,
    u128,
    FP80
);

make_field!(
    /// `GF(74769074762901517850839147140769382401)`, a 126-bit field. The generator has order `2^118`.
    Field126,
    u128,
    FP126
);

#[test]
fn test_arithmetic() {
    // TODO(cjpatton) Add tests for the other fields.
    use rand::prelude::*;

    let modulus = Field::modulus();

    // add
    assert_eq!(Field::from(modulus - 1) + Field::from(1), 0);
    assert_eq!(Field::from(modulus - 2) + Field::from(2), 0);
    assert_eq!(Field::from(modulus - 2) + Field::from(3), 1);
    assert_eq!(Field::from(1) + Field::from(1), 2);
    assert_eq!(Field::from(2) + Field::from(modulus), 2);
    assert_eq!(Field::from(3) + Field::from(modulus - 1), 2);

    // sub
    assert_eq!(Field::from(0) - Field::from(1), modulus - 1);
    assert_eq!(Field::from(1) - Field::from(2), modulus - 1);
    assert_eq!(Field::from(15) - Field::from(3), 12);
    assert_eq!(Field::from(1) - Field::from(1), 0);
    assert_eq!(Field::from(2) - Field::from(modulus), 2);
    assert_eq!(Field::from(3) - Field::from(modulus - 1), 4);

    // add + sub
    for _ in 0..100 {
        let f = Field::from(random::<u32>());
        let g = Field::from(random::<u32>());
        assert_eq!(f + g - f - g, 0);
        assert_eq!(f + g - g, f);
        assert_eq!(f + g - f, g);
    }

    // mul
    assert_eq!(Field::from(35) * Field::from(123), 4305);
    assert_eq!(Field::from(1) * Field::from(modulus), 0);
    assert_eq!(Field::from(0) * Field::from(123), 0);
    assert_eq!(Field::from(123) * Field::from(0), 0);
    assert_eq!(Field::from(123123123) * Field::from(123123123), 1237630077);

    // div
    assert_eq!(Field::from(35) / Field::from(5), 7);
    assert_eq!(Field::from(35) / Field::from(0), 0);
    assert_eq!(Field::from(0) / Field::from(5), 0);
    assert_eq!(Field::from(1237630077) / Field::from(123123123), 123123123);

    assert_eq!(Field::from(0).inv(), 0);

    // mul and div
    let uniform = rand::distributions::Uniform::from(1..modulus);
    let mut rng = thread_rng();
    for _ in 0..100 {
        // non-zero element
        let f = Field::from(uniform.sample(&mut rng));
        assert_eq!(f * f.inv(), 1);
        assert_eq!(f.inv() * f, 1);
    }

    // pow
    assert_eq!(Field::from(2).pow(3.into()), 8);
    assert_eq!(Field::from(3).pow(9.into()), 19683);
    assert_eq!(Field::from(51).pow(27.into()), 3760729523);
    assert_eq!(Field::from(432).pow(0.into()), 1);
    assert_eq!(Field(0).pow(123.into()), 0);
}

/// Merge two vectors of fields by summing other_vector into accumulator.
///
/// # Errors
///
/// Fails if the two vectors do not have the same length.
pub fn merge_vector(
    accumulator: &mut [Field],
    other_vector: &[Field],
) -> Result<(), FiniteFieldError> {
    if accumulator.len() != other_vector.len() {
        return Err(FiniteFieldError::InputSizeMismatch);
    }
    for (a, o) in accumulator.iter_mut().zip(other_vector.iter()) {
        *a += *o;
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::util::vector_with_length;
    use assert_matches::assert_matches;

    #[test]
    fn test_accumulate() {
        let mut lhs = vector_with_length(10);
        lhs.iter_mut().for_each(|f| *f = Field(1));
        let mut rhs = vector_with_length(10);
        rhs.iter_mut().for_each(|f| *f = Field(2));

        merge_vector(&mut lhs, &rhs).unwrap();

        lhs.iter().for_each(|f| assert_eq!(*f, Field(3)));
        rhs.iter().for_each(|f| assert_eq!(*f, Field(2)));

        let wrong_len = vector_with_length(9);
        let result = merge_vector(&mut lhs, &wrong_len);
        assert_matches!(result, Err(FiniteFieldError::InputSizeMismatch));
    }
}
