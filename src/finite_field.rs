// Copyright (c) 2020 Apple Inc.
// SPDX-License-Identifier: MPL-2.0

//! Finite field arithmetic over a prime field using a 32bit prime.

use crate::fp::{FP126, FP32, FP64, FP80};
use std::{
    cmp::min,
    convert::TryFrom,
    fmt::{Debug, Display, Formatter},
    ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Neg, Shr, Sub, SubAssign},
};

use rand::Rng;

// TODO(cjpatton) Rename To FieldError?
/// Possible errors from finite field operations.
#[derive(Debug, thiserror::Error)]
pub enum FiniteFieldError {
    /// Input sizes do not match
    #[error("input sizes do not match")]
    InputSizeMismatch,
    /// Returend by `FieldElement::read_from()` if the input buffer is too short.
    #[error("short read from byte slice")]
    FromBytesShortRead,
    /// Returend by `FieldElement::read_from()` if the input is larger than the modulus.
    #[error("read from byte slice exceeds modulus")]
    FromBytesModulusOverflow,
}

/// Objects with this trait represent an element of `GF(p)` for some prime `p`.
pub trait FieldElement:
    Sized
    + Debug
    + Copy
    + PartialEq
    + Eq
    + Add<Output = Self>
    + AddAssign
    + Sub<Output = Self>
    + SubAssign
    + Mul<Output = Self>
    + MulAssign
    + Div<Output = Self>
    + DivAssign
    + Neg<Output = Self>
    + Display
    + From<<Self as FieldElement>::Integer>
{
    /// Size of each field element in bytes.
    const BYTES: usize;

    /// The error returned if converting `usize` to an `Int` fails.
    type IntegerTryFromError: std::fmt::Debug;

    /// The integer representation of the field element.
    type Integer: Copy
        + Debug
        + PartialOrd
        + Div<Output = <Self as FieldElement>::Integer>
        + Shr<Output = <Self as FieldElement>::Integer>
        + Sub<Output = <Self as FieldElement>::Integer>
        + TryFrom<usize, Error = Self::IntegerTryFromError>;

    /// Modular exponentation, i.e., `self^exp (mod p)`.
    fn pow(&self, exp: Self::Integer) -> Self;

    /// Modular inversion, i.e., `self^-1 (mod p)`. If `self` is 0, then the output is undefined.
    fn inv(&self) -> Self;

    /// Returns the prime modulus `p`.
    fn modulus() -> Self::Integer;

    /// Writes the field element to the end of input buffer.
    fn append_to(&self, bytes: &mut Vec<u8>);

    /// Reads the next field element from the buffer.
    fn read_from(bytes: &[u8]) -> Result<Self, FiniteFieldError>;

    /// Returns the size of the multiplicative subgroup generated by `generator()`.
    fn generator_order() -> Self::Integer;

    /// Returns the generator of the multiplicative subgroup of size `generator_order()`.
    fn generator() -> Self;

    /// Returns the `2^l`-th principal root of unity for any `l <= 20`. Note that the `2^0`-th
    /// prinicpal root of unity is 1 by definition.
    fn root(l: usize) -> Option<Self>;

    /// Returns a random field element distributed uniformly over all field elements.
    fn rand<R: Rng + ?Sized>(rng: &mut R) -> Self;

    /// Returns the additive identity.
    fn zero() -> Self;
}

macro_rules! make_field {
    (
        $(#[$meta:meta])*
        $elem:ident, $int:ident, $fp:ident, $bytes:literal
    ) => {
        $(#[$meta])*
        #[derive(Clone, Copy, Debug, PartialOrd, Ord, Hash, Default)]
        pub struct $elem(u128);

        impl PartialEq for $elem {
            fn eq(&self, rhs: &Self) -> bool {
                $fp.from_elem(self.0) == $fp.from_elem(rhs.0)
            }
        }

        impl Eq for $elem {}

        impl Add for $elem {
            type Output = $elem;
            fn add(self, rhs: Self) -> Self {
                Self($fp.add(self.0, rhs.0))
            }
        }

        impl Add for &$elem {
            type Output = $elem;
            fn add(self, rhs: Self) -> $elem {
                *self + *rhs
            }
        }

        impl AddAssign for $elem {
            fn add_assign(&mut self, rhs: Self) {
                *self = *self + rhs;
            }
        }

        impl Sub for $elem {
            type Output = $elem;
            fn sub(self, rhs: Self) -> Self {
                Self($fp.sub(self.0, rhs.0))
            }
        }

        impl Sub for &$elem {
            type Output = $elem;
            fn sub(self, rhs: Self) -> $elem {
                *self - *rhs
            }
        }

        impl SubAssign for $elem {
            fn sub_assign(&mut self, rhs: Self) {
                *self = *self - rhs;
            }
        }

        impl Mul for $elem {
            type Output = $elem;
            fn mul(self, rhs: Self) -> Self {
                Self($fp.mul(self.0, rhs.0))
            }
        }

        impl Mul for &$elem {
            type Output = $elem;
            fn mul(self, rhs: Self) -> $elem {
                *self * *rhs
            }
        }

        impl MulAssign for $elem {
            fn mul_assign(&mut self, rhs: Self) {
                *self = *self * rhs;
            }
        }

        impl Div for $elem {
            type Output = $elem;
            fn div(self, rhs: Self) -> Self {
                self * rhs.inv()
            }
        }

        impl Div for &$elem {
            type Output = $elem;
            fn div(self, rhs: Self) -> $elem {
                *self / *rhs
            }
        }

        impl DivAssign for $elem {
            fn div_assign(&mut self, rhs: Self) {
                *self = *self / rhs;
            }
        }

        impl Neg for $elem {
            type Output = $elem;
            fn neg(self) -> Self {
                Self($fp.neg(self.0))
            }
        }

        impl Neg for &$elem {
            type Output = $elem;
            fn neg(self) -> $elem {
                -(*self)
            }
        }

        impl From<$int> for $elem {
            fn from(x: $int) -> Self {
                Self($fp.elem(u128::try_from(x).unwrap()))
            }
        }

        impl From<$elem> for $int {
            fn from(x: $elem) -> Self {
                $int::try_from($fp.from_elem(x.0)).unwrap()
            }
        }

        impl PartialEq<$int> for $elem {
            fn eq(&self, rhs: &$int) -> bool {
                $fp.from_elem(self.0) == u128::try_from(*rhs).unwrap()
            }
        }

        impl Display for $elem {
            fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {
                write!(f, "{}", $fp.from_elem(self.0))
            }
        }

        impl FieldElement for $elem {
            const BYTES: usize = $bytes;
            type Integer = $int;
            type IntegerTryFromError = <Self::Integer as TryFrom<usize>>::Error;

            fn pow(&self, exp: Self::Integer) -> Self {
                Self($fp.pow(self.0, u128::try_from(exp).unwrap()))
            }

            fn inv(&self) -> Self {
                Self($fp.inv(self.0))
            }

            fn modulus() -> Self::Integer {
                $fp.p as $int
            }

            fn append_to(&self, bytes: &mut Vec<u8>) {
                let int = $fp.from_elem(self.0);
                let mut slice = [0; Self::BYTES];
                for i in 0..Self::BYTES {
                    slice[i] = ((int >> (i << 3)) & 0xff) as u8;
                }
                bytes.extend_from_slice(&slice);
            }

            fn read_from(bytes: &[u8]) -> Result<Self, FiniteFieldError> {
                if Self::BYTES > bytes.len() {
                    return Err(FiniteFieldError::FromBytesShortRead);
                }

                let mut int = 0;
                for i in 0..Self::BYTES {
                    int |= (bytes[i] as u128) << (i << 3);
                }

                if int >= $fp.p {
                    return Err(FiniteFieldError::FromBytesModulusOverflow);
                }
                Ok(Self($fp.elem(int)))
            }

            fn generator() -> Self {
                Self($fp.g)
            }

            fn generator_order() -> Self::Integer {
                1 << (Self::Integer::try_from($fp.num_roots).unwrap())
            }

            fn root(l: usize) -> Option<Self> {
                if l < min($fp.roots.len(), $fp.num_roots+1) {
                    Some(Self($fp.roots[l]))
                } else {
                    None
                }
            }

            fn rand<R: Rng + ?Sized>(rng: &mut R) -> Self {
                Self($fp.rand_elem(rng))
            }

            fn zero() -> Self {
                Self(0)
            }
        }
    };
}

make_field!(
    /// `GF(4293918721)`, a 32-bit field. The generator has order `2^20`.
    Field32,
    u32,
    FP32,
    4
);

make_field!(
    /// `GF(15564440312192434177)`, a 64-bit field. The generator has order `2^59`.
    Field64,
    u64,
    FP64,
    8
);

make_field!(
    /// `GF(779190469673491460259841)`, an 80-bit field. The generator has order `2^72`.
    Field80,
    u128,
    FP80,
    10
);

make_field!(
    /// `GF(74769074762901517850839147140769382401)`, a 126-bit field. The generator has order `2^118`.
    Field126,
    u128,
    FP126,
    16
);

/// Merge two vectors of fields by summing other_vector into accumulator.
///
/// # Errors
///
/// Fails if the two vectors do not have the same length.
pub fn merge_vector<F: FieldElement>(
    accumulator: &mut [F],
    other_vector: &[F],
) -> Result<(), FiniteFieldError> {
    if accumulator.len() != other_vector.len() {
        return Err(FiniteFieldError::InputSizeMismatch);
    }
    for (a, o) in accumulator.iter_mut().zip(other_vector.iter()) {
        *a += *o;
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::fp::MAX_ROOTS;
    use crate::util::vector_with_length;
    use assert_matches::assert_matches;

    #[test]
    fn test_accumulate() {
        let mut lhs = vector_with_length(10);
        lhs.iter_mut().for_each(|f| *f = Field32(1));
        let mut rhs = vector_with_length(10);
        rhs.iter_mut().for_each(|f| *f = Field32(2));

        merge_vector(&mut lhs, &rhs).unwrap();

        lhs.iter().for_each(|f| assert_eq!(*f, Field32(3)));
        rhs.iter().for_each(|f| assert_eq!(*f, Field32(2)));

        let wrong_len = vector_with_length(9);
        let result = merge_vector(&mut lhs, &wrong_len);
        assert_matches!(result, Err(FiniteFieldError::InputSizeMismatch));
    }

    fn field_element_test<F: FieldElement>() {
        let mut rng = rand::thread_rng();
        let int_modulus = F::modulus();
        let int_one = F::Integer::try_from(1).unwrap();
        let zero = F::zero();
        let one = F::root(0).unwrap();
        let two = F::from(F::Integer::try_from(2).unwrap());
        let four = F::from(F::Integer::try_from(4).unwrap());

        // add
        assert_eq!(F::from(int_modulus - int_one) + one, zero);
        assert_eq!(one + one, two);
        assert_eq!(two + F::from(int_modulus), two);

        // sub
        assert_eq!(zero - one, F::from(int_modulus - int_one));
        assert_eq!(one - one, zero);
        assert_eq!(two - F::from(int_modulus), two);
        assert_eq!(one - F::from(int_modulus - int_one), two);

        // add + sub
        for _ in 0..100 {
            let f = F::rand(&mut rng);
            let g = F::rand(&mut rng);
            assert_eq!(f + g - f - g, zero);
            assert_eq!(f + g - g, f);
            assert_eq!(f + g - f, g);
        }

        // mul
        assert_eq!(two * two, four);
        assert_eq!(two * one, two);
        assert_eq!(two * zero, zero);
        assert_eq!(one * F::from(int_modulus), zero);

        // div
        assert_eq!(four / two, two);
        assert_eq!(two / two, one);
        assert_eq!(zero / two, zero);
        assert_eq!(two / zero, zero); // Undefined behavior
        assert_eq!(zero.inv(), zero); // Undefined behavior

        // mul + div
        for _ in 0..100 {
            let f = F::rand(&mut rng);
            if f == zero {
                println!("skipped zero");
                continue;
            }
            assert_eq!(f * f.inv(), one);
            assert_eq!(f.inv() * f, one);
        }

        // pow
        assert_eq!(two.pow(F::Integer::try_from(0).unwrap()), one);
        assert_eq!(two.pow(int_one), two);
        assert_eq!(two.pow(F::Integer::try_from(2).unwrap()), four);
        assert_eq!(two.pow(int_modulus - int_one), one);
        assert_eq!(two.pow(int_modulus), two);

        // roots
        let mut int_order = F::generator_order();
        for l in 0..MAX_ROOTS + 1 {
            assert_eq!(
                F::generator().pow(int_order),
                F::root(l).unwrap(),
                "failure for F::root({})",
                l
            );
            int_order = int_order >> int_one;
        }

        // serialization
        let test_inputs = vec![zero, one, F::rand(&mut rng), F::from(int_modulus - int_one)];
        for want in test_inputs.iter() {
            let mut bytes = vec![];
            want.append_to(&mut bytes);
            let got = F::read_from(&bytes).unwrap();
            assert_eq!(got, *want);
            assert_eq!(bytes.len(), F::BYTES);
        }
    }

    #[test]
    fn test_field32() {
        field_element_test::<Field32>();
    }

    #[test]
    fn test_field64() {
        field_element_test::<Field64>();
    }

    #[test]
    fn test_field80() {
        field_element_test::<Field80>();
    }

    #[test]
    fn test_field126() {
        field_element_test::<Field126>();
    }
}
